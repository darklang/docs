"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9080],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=d(n),k=r,m=c["".concat(s,".").concat(k)]||c[k]||p[k]||i;return n?a.createElement(m,l(l({ref:t},u),{},{components:n})):a.createElement(m,l({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},39494:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>k,frontMatter:()=>o,metadata:()=>d,toc:()=>p});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),l=["components"],o={},s="Datastores",d={unversionedId:"reference/framework/datastores",id:"reference/framework/datastores",title:"Datastores",description:"Overview",source:"@site/docs-classic/reference/framework/datastores.md",sourceDirName:"reference/framework",slug:"/reference/framework/datastores",permalink:"/reference/framework/datastores",draft:!1,editUrl:"https://github.com/darklang/docs/edit/main/docs-classic/reference/framework/datastores.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"HTTP Framework",permalink:"/reference/framework/http-framework"},next:{title:"Workers",permalink:"/reference/framework/workers"}},u={},p=[{value:"Overview",id:"overview",level:2},{value:"Keys",id:"keys",level:3},{value:"Values",id:"values",level:3},{value:"DB Functions",id:"db-functions",level:2},{value:"Adding a record to a Datastore",id:"adding-a-record-to-a-datastore",level:3},{value:"Datastore meta-actions",id:"datastore-meta-actions",level:3},{value:"Querying by key, <code>DB::get</code>",id:"querying-by-key-dbget",level:3},{value:"Querying by record field, <code>DB::queryExactField</code>",id:"querying-by-record-field-dbqueryexactfield",level:3},{value:"Querying by criteria, <code>DB::query</code> (experimental SQL Compiler)",id:"querying-by-criteria-dbquery-experimental-sql-compiler",level:3},{value:"Creating References Between DBs",id:"creating-references-between-dbs",level:3},{value:"Migrations, Locking, and Unlocking",id:"migrations-locking-and-unlocking",level:2},{value:"Using an External Datastore",id:"using-an-external-datastore",level:2}],c={toc:p};function k(e){var t=e.components,o=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"datastores"},"Datastores"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Datastores in Darklang are key-value based (persistent hash-maps). When you create a\nnew datastore, you specify the schema for the record."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Empty Datastore",src:n(16086).Z,width:"810",height:"230"})),(0,i.kt)("p",null,"The key is the unique identifier for each record, and is always of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". ",(0,i.kt)("strong",{parentName:"p"},"The key is not visible when looking at the Datastore's schema on the\ncanvas.")," You cannot mark a record field as the key, but you can use the same\nvalue for the field and the key when using ",(0,i.kt)("inlineCode",{parentName:"p"},"Db::set"),". An expected response when\nretrieving a set of records, with keys, is as following:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"[{key: { key1: value1, key2: value2} }, {key: { key1: value3, key2: value4}]")),(0,i.kt)("p",null,"You query datastores in four ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"By key (",(0,i.kt)("inlineCode",{parentName:"li"},"DB::get")," family)"),(0,i.kt)("li",{parentName:"ul"},"By specific field (",(0,i.kt)("inlineCode",{parentName:"li"},"DB::queryExactField")," family)"),(0,i.kt)("li",{parentName:"ul"},"By criteria for a specific field (",(0,i.kt)("inlineCode",{parentName:"li"},"DB::query")," family)"),(0,i.kt)("li",{parentName:"ul"},"By gathering information about the entire datastore")),(0,i.kt)("p",null,"Datastores return one or many results, with or without keys."),(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/_LqlHR55GZQ",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),(0,i.kt)("h3",{id:"keys"},"Keys"),(0,i.kt)("p",null,"The schema is the same for all of these key examples:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Datastore Schema",src:n(3338).Z,width:"828",height:"380"})),(0,i.kt)("p",null,"Some common key choices:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A unique field (like ",(0,i.kt)("inlineCode",{parentName:"li"},"userId"),"). If the field is not already a string use\n",(0,i.kt)("inlineCode",{parentName:"li"},"toString"),". The key is shown in the preview data.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'[{"1": { userId: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"2": { userId: 2, name: "Paul", pets: []}]')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A unique derivative of a field (like name and ",(0,i.kt)("inlineCode",{parentName:"li"},"UserId"),", or a slug).")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'[{"ellen1": { userId: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"paul2": { userId: 2, name: "Paul", pets: []}]')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A unique identifier generated programmatically (",(0,i.kt)("inlineCode",{parentName:"li"},"DB::generateKey"),").")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'[{"dee09c7e-6ede-402d-9ea4-4ee8fe843688": { id: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"ac7d4f1f-a164-4450-96f3-728b087bb9f4": { id: 2, name: "Paul", pets: []}]')),(0,i.kt)("h3",{id:"values"},"Values"),(0,i.kt)("p",null,"The datastore holds records. In the future, datastores will be defined by type,\nbut for now you manually create the schema. Available types are: String, Int,\nBool, Float, Password, Date, UUID, Dict (and lists of those)."),(0,i.kt)("h2",{id:"db-functions"},"DB Functions"),(0,i.kt)("p",null,"Datastore operators are built into the language. All functions are independently\nversioned. In your canvas you will see the latest version, as well as any\nversions you are currently using."),(0,i.kt)("p",null,"A list of all datastore functions is available\n",(0,i.kt)("a",{parentName:"p",href:"https://ops-documentation.builtwithdark.com/?pretty=1"},"in the function reference"),"."),(0,i.kt)("h3",{id:"adding-a-record-to-a-datastore"},"Adding a record to a Datastore"),(0,i.kt)("p",null,"To add items into a datastore, use ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::set"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::set")," takes three parameters\n(the record to be added, its unique key, and the datastore)."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"DBset",src:n(37049).Z,width:"1034",height:"176"})),(0,i.kt)("p",null,"For the earlier example datastore, using this with ",(0,i.kt)("inlineCode",{parentName:"p"},"userID")," as the key would\nlook as follows:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"DBset",src:n(10903).Z,width:"834",height:"462"})),(0,i.kt)("p",null,"Using the a generated key with ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::generateKey")," would look like this instead:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"DBset",src:n(10416).Z,width:"834",height:"434"})),(0,i.kt)("h3",{id:"datastore-meta-actions"},"Datastore meta-actions"),(0,i.kt)("p",null,"Some datastore functions provide ability to do something to the entire\ndatastore, and only require the datastore as the parameter."),(0,i.kt)("p",null,"Any datastore function that includes 'with keys' returns both the key and the\nvalue, a list of nested dictionaries\n",(0,i.kt)("inlineCode",{parentName:"p"},'[{"1": { userId: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"2": { userId: 2, name: "Paul", pets: []}]')),(0,i.kt)("p",null,"Functions that do not include 'with keys' return just the values, a list of\ndictionaries\n",(0,i.kt)("inlineCode",{parentName:"p"},'[{ userId: 1, name: "Ellen", pets: ["Gutenberg"]} , {userId: 2, name: "Paul", pets: []}]')),(0,i.kt)("p",null,"These include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::count")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::deleteAll")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::getAll")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::getAllwithKeys")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::keys")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::schemaFields")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::schema"))),(0,i.kt)("p",null,"To easily see is in your Datastore, create a REPL and running ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::getAll"),"."),(0,i.kt)("h3",{id:"querying-by-key-dbget"},"Querying by key, ",(0,i.kt)("inlineCode",{parentName:"h3"},"DB::get")),(0,i.kt)("p",null,"The key is a good way to be able to find information in the datastore. DB::get\nfinds records by key (reminder: ",(0,i.kt)("inlineCode",{parentName:"p"},"withKeys")," returns nested dictionaries including\nkeys, so ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::get")," does not return the key). Datastore functions that allow\naction based on key are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::delete")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::get")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::getMany")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::getManywithKeys"))),(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/qNA8FzGkdWI",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),(0,i.kt)("h3",{id:"querying-by-record-field-dbqueryexactfield"},"Querying by record field, ",(0,i.kt)("inlineCode",{parentName:"h3"},"DB::queryExactField")),(0,i.kt)("p",null,"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::queryExactField")," checks for a specific field within the record.\n",(0,i.kt)("inlineCode",{parentName:"p"},"DB::queryOnewithExactField")," finds one response, whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::queryExactFields"),"\nwill return as many as exist. (reminder: ",(0,i.kt)("inlineCode",{parentName:"p"},"withKeys")," returns nested dictionaries\nincluding keys)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::queryExactFields")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::queryExactFieldswithKey")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::queryOnewithExactField")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DB::queryOneWithExactFieldWithKey"))),(0,i.kt)("h3",{id:"querying-by-criteria-dbquery-experimental-sql-compiler"},"Querying by criteria, ",(0,i.kt)("inlineCode",{parentName:"h3"},"DB::query")," (experimental SQL Compiler)"),(0,i.kt)("p",null,"For being able to run more effective datastore queries, we also have a query\ncompiler. More about this feature is in this\n",(0,i.kt)("a",{parentName:"p",href:"https://blog.darklang.com/compiling-dark-to-sql"},"blog post"),"."),(0,i.kt)("p",null,"This allows you to write a function that can be evaluated for the datastore."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"DBset",src:n(76049).Z,width:"1414",height:"466"})),(0,i.kt)("p",null,"DB::query allows taking a datastore and a block filter. Note that this does not\ncheck every value in the table but rather is optimized to find data with\nindexes. Errors at compile-time if Darklang's compiler does not yet support the code\nin question (please let us know when you hit this, and which function you wanted\nto use!)"),(0,i.kt)("p",null,"You can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::querywithKey")," to get both the key and record,\n",(0,i.kt)("inlineCode",{parentName:"p"},"DB::queryOne")," to get only one response, and ",(0,i.kt)("inlineCode",{parentName:"p"},"DB::queryOnewithKey")," to get only\none response, with the key and record."),(0,i.kt)("h3",{id:"creating-references-between-dbs"},"Creating References Between DBs"),(0,i.kt)("p",null,"This canvas shows the way to create a reference between two datastores: in this\ncase between Darklang employees and their pets:\n",(0,i.kt)("a",{parentName:"p",href:"https://darklang.com/a/sample-database"},"https://darklang.com/a/sample-datastore")),(0,i.kt)("p",null,"Users have a pets field, which is a list of strings. The keys for the pets are\nadded to that list."),(0,i.kt)("h2",{id:"migrations-locking-and-unlocking"},"Migrations, Locking, and Unlocking"),(0,i.kt)("p",null,"You can edit the DB\u2019s schema (col names and types) until it has data in it, at\nwhich point it \u201clocks.\u201d Once a datastore is locked, there are several options\nfor changing the schema."),(0,i.kt)("p",null,"If you are still in development and don\u2019t need the data, creating a REPL and\ndeleting all data in a DB will unlock it (",(0,i.kt)("inlineCode",{parentName:"p"},"DB::deleteAll"),")."),(0,i.kt)("p",null,"To change your schema without deleting the data, you can use a live migration\nprocess. In the future, this will be built into Darklang, but for now you can follow\n",(0,i.kt)("a",{parentName:"p",href:"https://www.notion.so/paulshen/Datastore-migration-in-Dark-e8d50f81366b48fc92c980372f68d316"},"Paul Shen's excellent guide"),"\nto the process."),(0,i.kt)("h2",{id:"using-an-external-datastore"},"Using an External Datastore"),(0,i.kt)("p",null,"We strongly recommend using this built-in datastore. If you have an external\ndatabase, you can ",(0,i.kt)("a",{parentName:"p",href:"/walk-throughs/external-db"},"connect to it via REST"),"."))}k.isMDXComponent=!0},76049:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dbquery-8de003d4e5f9229982eed2abeac1b6a1.png"},10903:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dbset-689082b497d7b03806911b3debbd7164.png"},37049:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dbset_empty-9a3217d832b9b0722724eeffbf556e51.png"},10416:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dbset_genkey-ed8676f42310ef1abb6499847170b2ba.png"},16086:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/empty-5f599f97ce0de12bdb71910d636b435c.png"},3338:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/schema-915308f4dbbb1ab3c833227fb2d6ac0d.png"}}]);