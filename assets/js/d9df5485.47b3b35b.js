"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9656],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(t),h=i,m=c["".concat(s,".").concat(h)]||c[h]||u[h]||r;return t?a.createElement(m,o(o({ref:n},p),{},{components:t})):a.createElement(m,o({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},77343:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>l,contentTitle:()=>s,metadata:()=>d,toc:()=>p,default:()=>c});var a=t(87462),i=t(63366),r=(t(67294),t(3905)),o=["components"],l={title:"Adding a language feature"},s=void 0,d={unversionedId:"contributing/adding-a-language-feature",id:"contributing/adding-a-language-feature",title:"Adding a language feature",description:"There are a number of",source:"@site/docs/contributing/adding-a-language-feature.md",sourceDirName:"contributing",slug:"/contributing/adding-a-language-feature",permalink:"/contributing/adding-a-language-feature",editUrl:"https://github.com/darklang/docs/edit/main/docs/contributing/adding-a-language-feature.md",tags:[],version:"current",frontMatter:{title:"Adding a language feature"},sidebar:"Contributing",previous:{title:"Adding a built-in function",permalink:"/contributing/adding-a-function"},next:{title:"Adding a refactoring",permalink:"/contributing/adding-a-refactoring"}},p=[{value:"Overview",id:"overview",children:[],level:3},{value:"Backend",id:"backend",children:[{value:"Execution",id:"execution",children:[],level:3},{value:"Serialization",id:"serialization",children:[{value:"expr",id:"expr",children:[],level:4},{value:"Expressions are add-only",id:"expressions-are-add-only",children:[],level:4}],level:3}],level:2},{value:"Editor support",id:"editor-support",children:[{value:"Fluid Editor",id:"fluid-editor",children:[{value:"Adding tokens",id:"adding-tokens",children:[],level:4}],level:3},{value:"AST transformations",id:"ast-transformations",children:[],level:3}],level:2},{value:"Client/backend communication",id:"clientbackend-communication",children:[],level:2}],u={toc:p};function c(e){var n=e.components,t=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"There are a number of\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/issues?q=is%3Aissue+is%3Aopen+label%3Alanguage-feature"},"language features that we'd like to add"),"\nto Dark. While there a quite a few steps involved in adding a language feature,\nthey're typically relatively straightforward to add once you've figured out the\nDark codebase."),(0,r.kt)("p",null,"It's important to note that the most important part of a language feature is\ngetting agreement on what it does. We typically write specs for features, and\nensure that we have resolved how edge cases should work, as well as ensuring it\nmeshes with the rest of the language and language definition. If you're\ninterested in creating a language feature, you should engage with Paul Biggar\nearly and often."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"See also:\n",(0,r.kt)("a",{parentName:"em",href:"https://www.youtube.com/watch?v=HZk4yCF8DWQL"},"a pairing session where we added Tuples to the Dark client and backend"))),(0,r.kt)("h3",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Most language features will need to be added to our language definition. The\nlanguage definition is ",(0,r.kt)("inlineCode",{parentName:"p"},"Expr")," in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/fsharp-backend/src/LibExecution/RuntimeTypes.fs"},"F#"),",\nor ",(0,r.kt)("inlineCode",{parentName:"p"},"FluidExpression.t")," in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/libshared/FluidExpression.ml"},"ReScript"),',\nwhich represent a Dark expression (which in turn contains other Dark\nexpressions). This is commonly known as an "Abstract Syntax Tree" (or AST).'),(0,r.kt)("p",null,"At time of writing, the definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"Expr")," was"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"type Expr =\n  | EInteger of id * bigint\n  | EBool of id * bool\n  | EString of id * string\n  | ECharacter of id * string\n  // allow the user to have arbitrarily big numbers, even if they don't make sense as floats\n  | EFloat of id * Sign * bigint * bigint\n  | ENull of id\n  | EBlank of id\n  | ELet of id * string * Expr * Expr\n  | EIf of id * Expr * Expr * Expr\n  | EBinOp of id * FQFnName.T * Expr * Expr * SendToRail\n  | ELambda of id * List<id * string> * Expr\n  | EFieldAccess of id * Expr * string\n  | EVariable of id * string\n  | EFnCall of id * FQFnName.T * List<Expr> * SendToRail\n  | EPartial of id * string * Expr\n  | ERightPartial of id * string * Expr\n  | ELeftPartial of id * string * Expr\n  | EList of id * List<Expr>\n  | ERecord of id * List<string * Expr>\n  | EPipe of id * Expr * Expr * List<Expr>\n  | EConstructor of id * string * List<Expr>\n  | EMatch of id * Expr * List<Pattern * Expr>\n  | EPipeTarget of id\n  | EFeatureFlag of id * string * Expr * Expr * Expr\n")),(0,r.kt)("p",null,"The backend does the work of executing the expressions, and saving programs. The\nexecution engine is also compiled to Javascript in order to be available in the\nclient."),(0,r.kt)("p",null,'The client is responsible for editing programs. Typically, adding a language\nfeature means adding support for it to the many transformations that the client\ndoes, including refactorings, renamings, etc. It will also need support in the\n"Fluid" editor, which is where users actually type code.'),(0,r.kt)("h2",{id:"backend"},"Backend"),(0,r.kt)("h3",{id:"execution"},"Execution"),(0,r.kt)("p",null,"The execution of the language is defined in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/fsharp-backend/src/LibExecution/Interpreter.fs"},(0,r.kt)("inlineCode",{parentName:"a"},"fsharp-backend/LibExecution/Interpreter.fs:eval")),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"eval")," does the work of converting an expressions into a ",(0,r.kt)("inlineCode",{parentName:"p"},"dval")," -- a Dark value."),(0,r.kt)("p",null,"For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"DInt")," is the run-time value of an integer, while ",(0,r.kt)("inlineCode",{parentName:"p"},"EInteger")," is the\nexpression that represents an integer. ",(0,r.kt)("inlineCode",{parentName:"p"},"eval")," converts from an ",(0,r.kt)("inlineCode",{parentName:"p"},"EInteger")," that\nthe programmer added to their program, into a ",(0,r.kt)("inlineCode",{parentName:"p"},"DInt")," that can be operated on\n(added, subtracted, etc)."),(0,r.kt)("p",null,"As another example, an ",(0,r.kt)("inlineCode",{parentName:"p"},"ELet")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," statement in Dark. When you see"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let x = 6\nx + 4\n")),(0,r.kt)("p",null,"you have an ",(0,r.kt)("inlineCode",{parentName:"p"},'ELet ("x", EInteger 6, EBinOp ("+", EVariable "x", EInteger 4))'),".\nWhen we execute this ",(0,r.kt)("inlineCode",{parentName:"p"},"ELet"),", we first execute the ",(0,r.kt)("inlineCode",{parentName:"p"},"6"),", creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"dval")," of\n",(0,r.kt)("inlineCode",{parentName:"p"},"DInt 6"),", which we then store as ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),' in a "symbol table". We then execute\n',(0,r.kt)("inlineCode",{parentName:"p"},"x + 4")," using the symbol table with our known value of ",(0,r.kt)("inlineCode",{parentName:"p"},"x = 6"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dval"),"s are defined in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/fsharp-backend/src/LibExecution/RuntimeTypes.fs"},(0,r.kt)("inlineCode",{parentName:"a"},"fsharp-backend/LibExecution/RuntimeTypes.fs")),"\nand expressions are defined in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/libshared/FluidExpression.ml"},(0,r.kt)("inlineCode",{parentName:"a"},"libshared/FluidExpression.ml")),"."),(0,r.kt)("h3",{id:"serialization"},"Serialization"),(0,r.kt)("p",null,"The other main purpose of the backend is to save programs. Dark uses a fast\nbinary serialization format, derived directly from expressions. This means you\ndo not have to do anything special to allow users to save your new expression."),(0,r.kt)("h4",{id:"expr"},"expr"),(0,r.kt)("p",null,"Well, not exactly. We currently actually serialize using an\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/backend/libexecution/serialization_format.ml"},"OCaml definition of an old format, called ",(0,r.kt)("inlineCode",{parentName:"a"},"expr")),".\nWe\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/fsharp-backend/src/LibBackend/ProgramSerialization/OCamlInterop.fs"},"convert"),"\nbetween ",(0,r.kt)("inlineCode",{parentName:"p"},"expr")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Expr")," in order to save and execute. The client only uses\n",(0,r.kt)("inlineCode",{parentName:"p"},"Expr"),", however."),(0,r.kt)("h4",{id:"expressions-are-add-only"},"Expressions are add-only"),(0,r.kt)("p",null,"The automatic serialization has a caveat: the serializer has some rules to\nmaintain compatibility with existing Dark programs. You can add new expression\ntypes to it, but you can't change existing ones. This means that if you want to\nchange a language feature to make it more powerful, you need to instead add a\nnew version of it, rather than editing the current version."),(0,r.kt)("p",null,"We do have the ability to remove old formats, but it is a little challenging to\ncoordinate. Whenever we do this, it is always after the new replacement feature\nis live and stable, and then we go in and remove the old one."),(0,r.kt)("p",null,"These rules apply to anything using the ",(0,r.kt)("inlineCode",{parentName:"p"},"bin_io")," derivers, which currently\nincludes both ",(0,r.kt)("inlineCode",{parentName:"p"},"expr"),"s and ",(0,r.kt)("inlineCode",{parentName:"p"},"tipe"),"s."),(0,r.kt)("h2",{id:"editor-support"},"Editor support"),(0,r.kt)("p",null,"The editor is where the developer (a Dark user) actually creates code."),(0,r.kt)("h3",{id:"fluid-editor"},"Fluid Editor"),(0,r.kt)("p",null,'The "fluid" editor is the subpart of the client where users type code. It\nhandles keypresses and the AST transformations that they cause.'),(0,r.kt)("p",null,"For example: if you have the code (with the cursor denoted as ",(0,r.kt)("inlineCode",{parentName:"p"},"|"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let x = |6\nx + 4\n")),(0,r.kt)("p",null,"Pressing ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," with your cursor here makes the editor look up the current\nexpression, and add a ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," to the front of it. Here that converts ",(0,r.kt)("inlineCode",{parentName:"p"},"6")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"16"),"."),(0,r.kt)("p",null,'Over time we intend to expand the Fluid Editor for all "coding" text entry.'),(0,r.kt)("h4",{id:"adding-tokens"},"Adding tokens"),(0,r.kt)("p",null,'The FluidEditor works as a sort of "reverse parser". Instead of reading text and\nfiguring out meaning, it instead takes the AST and pretty-prints it into a set\nof ',(0,r.kt)("inlineCode",{parentName:"p"},"FluidToken"),"s. These tokens are stringified, showing the user textual code."),(0,r.kt)("p",null,"The tokens also tied the current edit back to an expression. In the example\nabove, the cursor is at the start of a ",(0,r.kt)("inlineCode",{parentName:"p"},"TInteger")," token, which ties the current\nposition back to the ",(0,r.kt)("inlineCode",{parentName:"p"},"EInteger")," expression that defines it."),(0,r.kt)("p",null,"To add a language feature, you will often need to add new tokens. You will\noccasionally reuse some tokens, but most features use dedicated tokens so that\nthere's no ambiguity."),(0,r.kt)("p",null,"You add tokens in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/client/src/core/Types.ml"},(0,r.kt)("inlineCode",{parentName:"a"},"client/src/core/Types.ml")),"\nand keystrokes are handled in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/client/src/fluid/Fluid.ml"},(0,r.kt)("inlineCode",{parentName:"a"},"client/src/fluid/Fluid.ml:updateKey")),"."),(0,r.kt)("h3",{id:"ast-transformations"},"AST transformations"),(0,r.kt)("p",null,"Once you have added the expression and the tokens, you will need to support\nexisting features. Mostly, this means that existing AST transformations and\nrefactorings should continue to work. These are typically either explicit (via\nthe command palette) or implicit (by renaming a variable)."),(0,r.kt)("p",null,"You will be able to find almost everywhere that this is needed when you add the\ndefinition to ",(0,r.kt)("inlineCode",{parentName:"p"},"Expr"),". The compiler will warn you at every place that you have\nnot handled it."),(0,r.kt)("h2",{id:"clientbackend-communication"},"Client/backend communication"),(0,r.kt)("p",null,"The client sends ASTs to the backend to save and to run the programs in the\ncloud. The client also fetches expressions from the backend to display and edit\nthem. It does this over JSON."),(0,r.kt)("p",null,"The F# backend has automatic JSON serializers and deserializers, using automatic\nserializers of types in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/fsharp-backend/src/ApiServer/Api"},"Api"),".\nThe client has hand-written serializers in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/client/src/core/Encoders.ml"},(0,r.kt)("inlineCode",{parentName:"a"},"client/src/core/Encoders.ml")),"\nand\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/dark/blob/main/client/src/core/Decoders.ml"},(0,r.kt)("inlineCode",{parentName:"a"},"client/src/core/Decoders.ml")),".\nThe OCaml compiler will prompt you to add new encoders, but not decoders.\nWriting new ones is straightforward by following other examples there."))}c.isMDXComponent=!0}}]);