"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[779],{2384:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=n(74848),s=n(28453);const r={title:"Making a Pull Request"},a=void 0,l={id:"contributing/making-a-pull-request",title:"Making a Pull Request",description:"Code Checklist",source:"@site/docs-classic/contributing/making-a-pull-request.md",sourceDirName:"contributing",slug:"/contributing/making-a-pull-request",permalink:"/contributing/making-a-pull-request",draft:!1,unlisted:!1,editUrl:"https://github.com/darklang/docs/edit/main/docs-classic/contributing/making-a-pull-request.md",tags:[],version:"current",frontMatter:{title:"Making a Pull Request"},sidebar:"Contributing",previous:{title:"Troubleshooting",permalink:"/contributing/troubleshooting"},next:{title:"New-Release Checklist",permalink:"/contributing/new-release-checklist"}},o={},c=[{value:"Code Checklist",id:"code-checklist",level:2},{value:"Writing a successful Pull Request message",id:"writing-a-successful-pull-request-message",level:2}];function u(e){const t={code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"code-checklist",children:"Code Checklist"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Never change an existing Darklang standard library function. Make a new one\n(with a new version) and deprecate the old one. It is however safe to fix the\ntype signature on an existing function, or to change its docstring."}),"\n",(0,i.jsxs)(t.li,{children:["Don't change existing serialized types, as that breaks the serializer.\nSerialized types are in ",(0,i.jsx)(t.code,{children:"backend/src/BinarySerialization/SerializedTypes.fs"}),"\nand have ",(0,i.jsx)(t.code,{children:"[<MessagePack.MessagePackObject>]"})," attributes annotating their type\ndefinitions."]}),"\n",(0,i.jsxs)(t.li,{children:["The code rendering step (",(0,i.jsx)(t.code,{children:"FluidEditorView.toHtml"}),") is extremely performance\nsensitive, and it's important that we don't add any steps that checks the\nentire AST on each token. Doing passes of the AST at the start (not in the\nloop) is fine."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"writing-a-successful-pull-request-message",children:"Writing a successful Pull Request message"}),"\n",(0,i.jsx)(t.p,{children:"When writing a pull request, there are some steps you can take to make it easier\nto accept the contribution."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"explain the problem you're solving. If this is explained elsewhere, link to it"}),"\n",(0,i.jsx)(t.li,{children:"explain how your solution addresses the problem"}),"\n",(0,i.jsx)(t.li,{children:"highlight any choices you've made in the implementation"}),"\n",(0,i.jsx)(t.li,{children:"make clear what the product and user-facing changes are, especially if it\ncould break anything for existing users"}),"\n",(0,i.jsx)(t.li,{children:"if the change is in the editor, include a before/after screenshot or GIF"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Highlighting these will make it much easier to know that this code is safe. The\npull request template asks for these."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var i=n(96540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);