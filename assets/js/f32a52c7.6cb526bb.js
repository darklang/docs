"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9080],{73407:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>o});var t=s(85893),i=s(11151);const r={},a="Datastores",d={id:"reference/framework/datastores",title:"Datastores",description:"Overview",source:"@site/docs-classic/reference/framework/datastores.md",sourceDirName:"reference/framework",slug:"/reference/framework/datastores",permalink:"/reference/framework/datastores",draft:!1,unlisted:!1,editUrl:"https://github.com/darklang/docs/edit/main/docs-classic/reference/framework/datastores.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"HTTP Framework",permalink:"/reference/framework/http-framework"},next:{title:"Workers",permalink:"/reference/framework/workers"}},l={},o=[{value:"Overview",id:"overview",level:2},{value:"Keys",id:"keys",level:3},{value:"Values",id:"values",level:3},{value:"DB Functions",id:"db-functions",level:2},{value:"Adding a record to a Datastore",id:"adding-a-record-to-a-datastore",level:3},{value:"Datastore meta-actions",id:"datastore-meta-actions",level:3},{value:"Querying by key, <code>DB::get</code>",id:"querying-by-key-dbget",level:3},{value:"Querying by record field, <code>DB::queryExactField</code>",id:"querying-by-record-field-dbqueryexactfield",level:3},{value:"Querying by criteria, <code>DB::query</code> (experimental SQL Compiler)",id:"querying-by-criteria-dbquery-experimental-sql-compiler",level:3},{value:"Creating References Between DBs",id:"creating-references-between-dbs",level:3},{value:"Migrations, Locking, and Unlocking",id:"migrations-locking-and-unlocking",level:2},{value:"Using an External Datastore",id:"using-an-external-datastore",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"datastores",children:"Datastores"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Datastores in Darklang are key-value based (persistent hash-maps). When you create a\nnew datastore, you specify the schema for the record."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Empty Datastore",src:s(16086).Z+"",width:"810",height:"230"})}),"\n",(0,t.jsxs)(n.p,{children:["The key is the unique identifier for each record, and is always of type\n",(0,t.jsx)(n.code,{children:"string"}),". ",(0,t.jsx)(n.strong,{children:"The key is not visible when looking at the Datastore's schema on the\ncanvas."})," You cannot mark a record field as the key, but you can use the same\nvalue for the field and the key when using ",(0,t.jsx)(n.code,{children:"Db::set"}),". An expected response when\nretrieving a set of records, with keys, is as following:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"[{key: { key1: value1, key2: value2} }, {key: { key1: value3, key2: value4}]"})}),"\n",(0,t.jsx)(n.p,{children:"You query datastores in four ways:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["By key (",(0,t.jsx)(n.code,{children:"DB::get"})," family)"]}),"\n",(0,t.jsxs)(n.li,{children:["By specific field (",(0,t.jsx)(n.code,{children:"DB::queryExactField"})," family)"]}),"\n",(0,t.jsxs)(n.li,{children:["By criteria for a specific field (",(0,t.jsx)(n.code,{children:"DB::query"})," family)"]}),"\n",(0,t.jsx)(n.li,{children:"By gathering information about the entire datastore"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Datastores return one or many results, with or without keys."}),"\n",(0,t.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/_LqlHR55GZQ",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",(0,t.jsx)(n.h3,{id:"keys",children:"Keys"}),"\n",(0,t.jsx)(n.p,{children:"The schema is the same for all of these key examples:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Datastore Schema",src:s(3338).Z+"",width:"828",height:"380"})}),"\n",(0,t.jsx)(n.p,{children:"Some common key choices:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A unique field (like ",(0,t.jsx)(n.code,{children:"userId"}),"). If the field is not already a string use\n",(0,t.jsx)(n.code,{children:"toString"}),". The key is shown in the preview data."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:'[{"1": { userId: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"2": { userId: 2, name: "Paul", pets: []}]'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A unique derivative of a field (like name and ",(0,t.jsx)(n.code,{children:"UserId"}),", or a slug)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:'[{"ellen1": { userId: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"paul2": { userId: 2, name: "Paul", pets: []}]'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A unique identifier generated programmatically (",(0,t.jsx)(n.code,{children:"DB::generateKey"}),")."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:'[{"dee09c7e-6ede-402d-9ea4-4ee8fe843688": { id: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"ac7d4f1f-a164-4450-96f3-728b087bb9f4": { id: 2, name: "Paul", pets: []}]'})}),"\n",(0,t.jsx)(n.h3,{id:"values",children:"Values"}),"\n",(0,t.jsx)(n.p,{children:"The datastore holds records. In the future, datastores will be defined by type,\nbut for now you manually create the schema. Available types are: String, Int,\nBool, Float, Password, Date, UUID, Dict (and lists of those)."}),"\n",(0,t.jsx)(n.h2,{id:"db-functions",children:"DB Functions"}),"\n",(0,t.jsx)(n.p,{children:"Datastore operators are built into the language. All functions are independently\nversioned. In your canvas you will see the latest version, as well as any\nversions you are currently using."}),"\n",(0,t.jsxs)(n.p,{children:["A list of all datastore functions is available\n",(0,t.jsx)(n.a,{href:"https://ops-documentation.builtwithdark.com/?pretty=1",children:"in the function reference"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"adding-a-record-to-a-datastore",children:"Adding a record to a Datastore"}),"\n",(0,t.jsxs)(n.p,{children:["To add items into a datastore, use ",(0,t.jsx)(n.code,{children:"DB::set"}),". ",(0,t.jsx)(n.code,{children:"DB::set"})," takes three parameters\n(the record to be added, its unique key, and the datastore)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"DBset",src:s(37049).Z+"",width:"1034",height:"176"})}),"\n",(0,t.jsxs)(n.p,{children:["For the earlier example datastore, using this with ",(0,t.jsx)(n.code,{children:"userID"})," as the key would\nlook as follows:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"DBset",src:s(10903).Z+"",width:"834",height:"462"})}),"\n",(0,t.jsxs)(n.p,{children:["Using the a generated key with ",(0,t.jsx)(n.code,{children:"DB::generateKey"})," would look like this instead:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"DBset",src:s(10416).Z+"",width:"834",height:"434"})}),"\n",(0,t.jsx)(n.h3,{id:"datastore-meta-actions",children:"Datastore meta-actions"}),"\n",(0,t.jsx)(n.p,{children:"Some datastore functions provide ability to do something to the entire\ndatastore, and only require the datastore as the parameter."}),"\n",(0,t.jsxs)(n.p,{children:["Any datastore function that includes 'with keys' returns both the key and the\nvalue, a list of nested dictionaries\n",(0,t.jsx)(n.code,{children:'[{"1": { userId: 1, name: "Ellen", pets: ["Gutenberg"]} }, {"2": { userId: 2, name: "Paul", pets: []}]'})]}),"\n",(0,t.jsxs)(n.p,{children:["Functions that do not include 'with keys' return just the values, a list of\ndictionaries\n",(0,t.jsx)(n.code,{children:'[{ userId: 1, name: "Ellen", pets: ["Gutenberg"]} , {userId: 2, name: "Paul", pets: []}]'})]}),"\n",(0,t.jsx)(n.p,{children:"These include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::count"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::deleteAll"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::getAll"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::getAllwithKeys"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::keys"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::schemaFields"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::schema"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To easily see is in your Datastore, create a REPL and running ",(0,t.jsx)(n.code,{children:"DB::getAll"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"querying-by-key-dbget",children:["Querying by key, ",(0,t.jsx)(n.code,{children:"DB::get"})]}),"\n",(0,t.jsxs)(n.p,{children:["The key is a good way to be able to find information in the datastore. DB::get\nfinds records by key (reminder: ",(0,t.jsx)(n.code,{children:"withKeys"})," returns nested dictionaries including\nkeys, so ",(0,t.jsx)(n.code,{children:"DB::get"})," does not return the key). Datastore functions that allow\naction based on key are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::delete"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::get"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::getMany"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::getManywithKeys"})}),"\n"]}),"\n",(0,t.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/qNA8FzGkdWI",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",(0,t.jsxs)(n.h3,{id:"querying-by-record-field-dbqueryexactfield",children:["Querying by record field, ",(0,t.jsx)(n.code,{children:"DB::queryExactField"})]}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.code,{children:"DB::queryExactField"})," checks for a specific field within the record.\n",(0,t.jsx)(n.code,{children:"DB::queryOnewithExactField"})," finds one response, whereas ",(0,t.jsx)(n.code,{children:"DB::queryExactFields"}),"\nwill return as many as exist. (reminder: ",(0,t.jsx)(n.code,{children:"withKeys"})," returns nested dictionaries\nincluding keys)."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::queryExactFields"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::queryExactFieldswithKey"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::queryOnewithExactField"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DB::queryOneWithExactFieldWithKey"})}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"querying-by-criteria-dbquery-experimental-sql-compiler",children:["Querying by criteria, ",(0,t.jsx)(n.code,{children:"DB::query"})," (experimental SQL Compiler)"]}),"\n",(0,t.jsxs)(n.p,{children:["For being able to run more effective datastore queries, we also have a query\ncompiler. More about this feature is in this\n",(0,t.jsx)(n.a,{href:"https://blog.darklang.com/compiling-dark-to-sql",children:"blog post"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This allows you to write a function that can be evaluated for the datastore."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"DBset",src:s(76049).Z+"",width:"1414",height:"466"})}),"\n",(0,t.jsx)(n.p,{children:"DB::query allows taking a datastore and a block filter. Note that this does not\ncheck every value in the table but rather is optimized to find data with\nindexes. Errors at compile-time if Darklang's compiler does not yet support the code\nin question (please let us know when you hit this, and which function you wanted\nto use!)"}),"\n",(0,t.jsxs)(n.p,{children:["You can also use ",(0,t.jsx)(n.code,{children:"DB::querywithKey"})," to get both the key and record,\n",(0,t.jsx)(n.code,{children:"DB::queryOne"})," to get only one response, and ",(0,t.jsx)(n.code,{children:"DB::queryOnewithKey"})," to get only\none response, with the key and record."]}),"\n",(0,t.jsx)(n.h3,{id:"creating-references-between-dbs",children:"Creating References Between DBs"}),"\n",(0,t.jsxs)(n.p,{children:["This canvas shows the way to create a reference between two datastores: in this\ncase between Darklang employees and their pets:\n",(0,t.jsx)(n.a,{href:"https://darklang.com/a/sample-database",children:"https://darklang.com/a/sample-datastore"})]}),"\n",(0,t.jsx)(n.p,{children:"Users have a pets field, which is a list of strings. The keys for the pets are\nadded to that list."}),"\n",(0,t.jsx)(n.h2,{id:"migrations-locking-and-unlocking",children:"Migrations, Locking, and Unlocking"}),"\n",(0,t.jsx)(n.p,{children:"You can edit the DB\u2019s schema (col names and types) until it has data in it, at\nwhich point it \u201clocks.\u201d Once a datastore is locked, there are several options\nfor changing the schema."}),"\n",(0,t.jsxs)(n.p,{children:["If you are still in development and don\u2019t need the data, creating a REPL and\ndeleting all data in a DB will unlock it (",(0,t.jsx)(n.code,{children:"DB::deleteAll"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["To change your schema without deleting the data, you can use a live migration\nprocess. In the future, this will be built into Darklang, but for now you can follow\n",(0,t.jsx)(n.a,{href:"https://www.notion.so/paulshen/Datastore-migration-in-Dark-e8d50f81366b48fc92c980372f68d316",children:"Paul Shen's excellent guide"}),"\nto the process."]}),"\n",(0,t.jsx)(n.h2,{id:"using-an-external-datastore",children:"Using an External Datastore"}),"\n",(0,t.jsxs)(n.p,{children:["We strongly recommend using this built-in datastore. If you have an external\ndatabase, you can ",(0,t.jsx)(n.a,{href:"/walk-throughs/external-db",children:"connect to it via REST"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},76049:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/dbquery-8de003d4e5f9229982eed2abeac1b6a1.png"},10903:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/dbset-689082b497d7b03806911b3debbd7164.png"},37049:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/dbset_empty-9a3217d832b9b0722724eeffbf556e51.png"},10416:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/dbset_genkey-ed8676f42310ef1abb6499847170b2ba.png"},16086:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/empty-5f599f97ce0de12bdb71910d636b435c.png"},3338:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/schema-915308f4dbbb1ab3c833227fb2d6ac0d.png"},11151:(e,n,s)=>{s.d(n,{Z:()=>d,a:()=>a});var t=s(67294);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);