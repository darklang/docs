"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4233],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(t),c=i,h=m["".concat(o,".").concat(c)]||m[c]||d[c]||r;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},21005:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>p,toc:()=>d});var a=t(87462),i=t(63366),r=(t(67294),t(3905)),l=["components"],s={title:"F# for Darklang developers"},o=void 0,p={unversionedId:"contributing/fsharp-for-dark-developers",id:"contributing/fsharp-for-dark-developers",title:"F# for Darklang developers",description:"This guide aims to introduce you to enough F# contribute to Darklang, assuming",source:"@site/docs/contributing/fsharp-for-dark-developers.md",sourceDirName:"contributing",slug:"/contributing/fsharp-for-dark-developers",permalink:"/contributing/fsharp-for-dark-developers",draft:!1,editUrl:"https://github.com/darklang/docs/edit/main/docs/contributing/fsharp-for-dark-developers.md",tags:[],version:"current",frontMatter:{title:"F# for Darklang developers"},sidebar:"Contributing",previous:{title:"Adding a refactoring",permalink:"/contributing/adding-a-refactoring"},next:{title:"General concepts",permalink:"/contributing/general-concepts"}},u={},d=[{value:"Some simple F# code",id:"some-simple-f-code",level:2},{value:"Darklang vs F#",id:"darklang-vs-f",level:2},{value:"Types",id:"types",level:3},{value:"Functions",id:"functions",level:3},{value:"Standard library",id:"standard-library",level:3},{value:"Int",id:"int",level:3},{value:"Float",id:"float",level:3},{value:"Bool",id:"bool",level:3},{value:"String",id:"string",level:3},{value:"String Interpolation",id:"string-interpolation",level:3},{value:"List",id:"list",level:3},{value:"Records",id:"records",level:3},{value:"Let",id:"let",level:3},{value:"If",id:"if",level:3},{value:"Operators",id:"operators",level:3},{value:"Match",id:"match",level:3},{value:"Variants",id:"variants",level:3},{value:"Lambdas",id:"lambdas",level:3},{value:"Pipes",id:"pipes",level:3},{value:"Dictionaries",id:"dictionaries",level:3},{value:"Unit",id:"unit",level:3},{value:"Error handling",id:"error-handling",level:3},{value:"Exceptions",id:"exceptions",level:4},{value:"Imperative programming",id:"imperative-programming",level:3},{value:"Async/Tasks",id:"asynctasks",level:3},{value:"Advanced functions",id:"advanced-functions",level:3},{value:"Partial application / currying",id:"partial-application--currying",level:4},{value:"Darklang&#39;s codebase history",id:"darklangs-codebase-history",level:2}],m={toc:d};function c(e){var n=e.components,t=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This guide aims to introduce you to enough F# contribute to Darklang, assuming\nyou already know Darklang."),(0,r.kt)("h2",{id:"some-simple-f-code"},"Some simple F","#"," code"),(0,r.kt)("p",null,"Darklang and F# are very similar. Here's an example function in F#:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'let someFunction (intArgument : int) : string =\n  let aString = "myString"\n  let anInt = 65 + intArgument\n  let aFloat = 6.72\n  anotherFunction aString anInt aFloat\n')),(0,r.kt)("p",null,"This is a function called ",(0,r.kt)("inlineCode",{parentName:"p"},"someFunction"),", which takes one argument, an ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),"\ncalled ",(0,r.kt)("inlineCode",{parentName:"p"},"intArgument"),", and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". Three variables are defined in the\nbody, first a string, then an int, then a float, and finally we call the\n",(0,r.kt)("inlineCode",{parentName:"p"},"anotherFunction")," function with all three parameters as arguments."),(0,r.kt)("p",null,"In Darklang this would be written:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'someFunction\n  intArgument : Int\n  \u21aa String\n\nlet aString = "myString"\nlet anInt = 65 + intArgument\nlet aFloat = 6.72\nanotherFunction aString anInt aFloat\n')),(0,r.kt)("h2",{id:"darklang-vs-f"},"Darklang vs F","#"),(0,r.kt)("p",null,"Darklang and F# are all influenced by OCaml. Though Darklang is currently a\nsubset of these languages, Darklang will continue to grow some more of their\nfeatures. We'll discuss the similarities and differences as we go through\nlanguage features."),(0,r.kt)("h3",{id:"types"},"Types"),(0,r.kt)("p",null,"F# is a strongly typed-languages. Darklang aspires to be, but it doesn't have a\ntype-checker yet. This shows the biggest difference in between working in these\nlanguages, that the compiler will refuse to compile if the types are wrong."),(0,r.kt)("p",null,"F# has type-inference, which means that the compiler will try and figure out\nwhat the types are. Usually type errors actually contain useful information, but\nthey need to be read very carefully to find it."),(0,r.kt)("p",null,"We've found the best way to debug incorrect types is to add type annotations to\neverything. We add them to all functions (we didn't always do this, but we do\nnow, but we are now), including all parameters and return types (see\n",(0,r.kt)("a",{parentName:"p",href:"#functions"},"example")," below)."),(0,r.kt)("p",null,"In F#, you can actually add types in many places where they aren't required,\nsuch as variable definitions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let y = 6.7\nlet (x : int) = 6\nx + 5\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"x")," here, despite being a normal variable definition, has a type signature. F#\nallows this in many places, and it's useful for tracking down these errors."),(0,r.kt)("p",null,"We'll discuss declaring types below."),(0,r.kt)("h3",{id:"functions"},"Functions"),(0,r.kt)("p",null,"Functions in F# are defined in the outer scope. Type signatures are optional but\nwe always use them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'let myFunction (arg1 : int) (arg2 : string) : string =\n  if arg1 < (String.toInt arg2)\n  then "just return a string"\n  else arg2\n')),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"myFunction")," has two arguments, ",(0,r.kt)("inlineCode",{parentName:"p"},"arg1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"arg2"),", which are an ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"string")," respectively. It returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,r.kt)("p",null,"Like in Darklang, the body of a function is just an expression, and it\nautomatically returns the result of that expression."),(0,r.kt)("p",null,"(see ",(0,r.kt)("a",{parentName:"p",href:"#advanced-functions"},"below")," for more details on functions in F#)"),(0,r.kt)("h3",{id:"standard-library"},"Standard library"),(0,r.kt)("p",null,"Most of the code in Darklang uses\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/darklang/tablecloth"},"Tablecloth"),"."),(0,r.kt)("p",null,"Note: for implementing the standard libraries, we do not use Tablecloth as it is\nstill pretty new and may be in flux. Instead, we try to make sure that we use\nlibraries from ",(0,r.kt)("inlineCode",{parentName:"p"},".NET"),", FSharp.Core, or if necessary, the FSharpPlus library."),(0,r.kt)("h3",{id:"int"},"Int"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," is the same in Darklang and F#, same syntax, same meaning. Note that\nints are 32-bit in F#, and 64-bit in Darklang."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let x = 5\nx + 6\n")),(0,r.kt)("h3",{id:"float"},"Float"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," is the same in Darklang and F#, both of them are 64-bit floating point\nnumbers."),(0,r.kt)("p",null,"To convert from floats to ints use ",(0,r.kt)("inlineCode",{parentName:"p"},"Float.toInt"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"Float.round"),"."),(0,r.kt)("h3",{id:"bool"},"Bool"),(0,r.kt)("p",null,"Like in Darklang, ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),"s in F# are either ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("h3",{id:"string"},"String"),(0,r.kt)("p",null,"Strings are Unicode in Darklang and F#. While you're unlikely to hit differences\nin practice, they do actually use a different in-memory representation, with\nDarklang using UTF-8, and F# using .NET's UTF-16."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'let myString = "some string, escaping is allowed\\nwhich dark doesn\'t support yet" in\nmyString\n')),(0,r.kt)("h3",{id:"string-interpolation"},"String Interpolation"),(0,r.kt)("p",null,"Darklang and F# support string interpolation. In F#:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'let x = 6\nlet y = 7.8\nlet myString = $"some string with x: {x} and also {y}"\n')),(0,r.kt)("h3",{id:"list"},"List"),(0,r.kt)("p",null,"Lists in Darklang and F# are almost the same. In F#, lists use ",(0,r.kt)("inlineCode",{parentName:"p"},";")," as\nseparators, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"[1; 2; 3; 4]\n")),(0,r.kt)("p",null,"(However, F# allows separators to be omitted which the list elements are lined\nup vertically, as it uses indentation as the separator)."),(0,r.kt)("p",null,"While Darklang technically allows you to create lists that have different types\nin them (which you should not do), F# emphatically does not."),(0,r.kt)("p",null,"To type check a list in F#, you use ",(0,r.kt)("inlineCode",{parentName:"p"},"List<int>"),"."),(0,r.kt)("h3",{id:"records"},"Records"),(0,r.kt)("p",null,"Records are mostly used as objects are in most languages. Like Darklang, they\nonly have fields, not methods, and you use functions to manipulate them."),(0,r.kt)("p",null,"F# uses a familiar syntax, but with ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},":"),". It also allows you tes\nuse indentation instead of separators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'{\n  field1 = 56\n  field2 = true\n  field3 = "asd"\n}\n')),(0,r.kt)("p",null,"Note that F# uses ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," to connect a field and a value, and ",(0,r.kt)("inlineCode",{parentName:"p"},";")," as row separator.\nThe types of the fields do not have to be declared."),(0,r.kt)("p",null,"Records are immutable, like almost everything in F#, and are updated using an\nunusual syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let x = { field1 = 56; field2 = true }\nlet updatedX = { x with field1 = 57 }\ndoSomethingWith updatedX\n")),(0,r.kt)("p",null,"Note that records in Darklang are really dictionaries, which is why you update\nthem with ",(0,r.kt)("inlineCode",{parentName:"p"},"Dict::set"),". We're trying to figure out how to split records and\ndictionaries apart better in Darklang, after which they will be more like F#."),(0,r.kt)("p",null,"Type definitions for records look like this in F#:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"type Person =\n  {\n    name : string\n  ; age : int\n  }\n")),(0,r.kt)("h3",{id:"let"},"Let"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"let"),"s in F# are the same as in Darklang:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let x = 45\nx + 23\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"let")," also allow destructing in F#, although we don't currently use that very\noften."),(0,r.kt)("h3",{id:"if"},"If"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"if")," statements in F# are extremely similar to Darklang, including that they\nonly allow ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),"s as the condition, and in their syntax."),(0,r.kt)("p",null,"In F#:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'if hasAccess user\nthen "Welcome!"\nelse "Access denied"\n')),(0,r.kt)("h3",{id:"operators"},"Operators"),(0,r.kt)("p",null,"F# has some unusual operators. Most importantly, the equality operator is ",(0,r.kt)("inlineCode",{parentName:"p"},"="),"\n(that's just one equals sign), whereas in most languages it's ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," (including\nDarklang). ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," is very strict equality, equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"===")," in languages that\nhave that, such as JS."),(0,r.kt)("p",null,"F# also has a ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," operator, but you should never use it."),(0,r.kt)("p",null,"F# use ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," for inequality (",(0,r.kt)("inlineCode",{parentName:"p"},"!=")," in Darklang)."),(0,r.kt)("h3",{id:"match"},"Match"),(0,r.kt)("p",null,"Darklang has a ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," statement that is very similar to F#, with slightly\ndifferent syntax. In Darklang you write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"match myValue\n  Some x -> 5\n  _ -> 6\n")),(0,r.kt)("p",null,"while in F# you write"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"match myValue with\n| Some x -> 5\n| _ -> 6\n")),(0,r.kt)("p",null,"Notice the ",(0,r.kt)("inlineCode",{parentName:"p"},"with")," keyword, and starting the patterns with ",(0,r.kt)("inlineCode",{parentName:"p"},"|"),"."),(0,r.kt)("p",null,"F# also support more powerful ",(0,r.kt)("inlineCode",{parentName:"p"},"match"),"es, for example multiple patterns can match\na single branch:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'match myValue with\n| 4 | 5 | 6 -> "between 4 and 6"\n| _ -> "not between 4 and 6"\n')),(0,r.kt)("p",null,"F# also supports the ",(0,r.kt)("inlineCode",{parentName:"p"},"when")," clause:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'match myValue with\n| Some myInt when myInt >= 4 && myInt <= 6 -> "between 4 and 6"\n| _ -> "not between 4 and 6"\n')),(0,r.kt)("h3",{id:"variants"},"Variants"),(0,r.kt)("p",null,"Darklang has a handful of enums for ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," types: ",(0,r.kt)("inlineCode",{parentName:"p"},"Just"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Error"),". In the future we will expand this to allow\nuser-defined types as well."),(0,r.kt)("p",null,"F# supports the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," types and we use them a lot. However, the\nconstructors for Option are named differently; both languages use: ",(0,r.kt)("inlineCode",{parentName:"p"},"Some")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"None")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"Just")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),"."),(0,r.kt)("p",null,'These enums are typically called "variants". We use them frequently, especially\nto represent expressions. For example in ',(0,r.kt)("inlineCode",{parentName:"p"},"FluidExpression.fs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"type Expr =\n  | EInteger of id * int64\n  | EBool of id * bool\n  | EString of id * string\n  | EFloat of id * string * string\n  | ENull of id\n  | EBlank of id\n  | ELet of id * string * Expr * Expr\n  | EIf of id * Expr * Expr * Expr\n  | EBinOp of id * string * Expr * Expr * sendToRail\n  | ELambda of id * List<(analysisID * string)> * Expr\n  | EFieldAccess of id * Expr * string\n  | EVariable of id * string\n  | EFnCall of id * string * List<Expr> * sendToRail\n  | EList of id * List<Expr>\n  | ERecord of id * (string * Expr) list\n  | EPipe of id * List<Expr>\n  | EConstructor of id * string * List<Expr>\n  | EMatch of id * Expr * List<(MatchPattern * Expr)>\n  | EPipeTarget of id\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'let expr = EInteger (id, "test")\n')),(0,r.kt)("p",null,"To get values from them, you pattern match:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'match expr with\n| EInteger (_, str) -> str\n| _ -> "not an int"\n')),(0,r.kt)("h3",{id:"lambdas"},"Lambdas"),(0,r.kt)("p",null,"F# supports lambdas and we use them frequently. They have a different syntax to\nDarklang, F# uses:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"list\n|> List.map (fun elem -> elem + 2)\n")),(0,r.kt)("h3",{id:"pipes"},"Pipes"),(0,r.kt)("p",null,'Both languages have pipes which are the same as in Darklang. In Darklang, the\npassed argument goes into the first position. That is not true F#, where it goes\ninto the last position. As a result, we tend to put the "subject" of the\nfunction in the pipeable position (first in Darklang, last in F#).'),(0,r.kt)("h3",{id:"dictionaries"},"Dictionaries"),(0,r.kt)("p",null,"Dictionaries (hash-maps, etc) are called ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," in F#."),(0,r.kt)("h3",{id:"unit"},"Unit"),(0,r.kt)("p",null,"F# and Darklang have a ",(0,r.kt)("inlineCode",{parentName:"p"},"unit")," type, whose only member is ",(0,r.kt)("inlineCode",{parentName:"p"},"()"),". That's an actual\nvalue, for example, all this is valid code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let falseVar = () != () in\n")),(0,r.kt)("p",null,"It's typically used to pass to a function which is impure but doesn't have any\nmeaningful arguments, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"gid ()")," (which generates IDs)."),(0,r.kt)("h3",{id:"error-handling"},"Error handling"),(0,r.kt)("p",null,"Typically we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Option"),"s for error handling. You'll very commonly\nsee something like"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let isRailable (m : model) (name : string) =\n  m.functions\n  |> Functions.find name\n  |> Option.map (fun fn ->\n         fn.fnReturnTipe = TOption || fn.fnReturnTipe = TResult)\n  |> Option.withDefault false\n")),(0,r.kt)("p",null,"To find out if a function goes on the error rail, we search for a function,\nwhich returns an Option. We then use a ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," to operate on the option, and\nfinally choose a default in case the Option returned ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,r.kt)("h4",{id:"exceptions"},"Exceptions"),(0,r.kt)("p",null,"F# has exceptions - thought we'd like to use them less."),(0,r.kt)("p",null,"Unfortunately, it's hard to tell when an exception could be thrown."),(0,r.kt)("h3",{id:"imperative-programming"},"Imperative programming"),(0,r.kt)("p",null,"F# supports imperative programming which Darklang does not support yet."),(0,r.kt)("p",null,"F# has mutable values that it prefers to refs (it has refs, but they're\ndeprecated). Mutable values are used like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'let mutable myString = "old value"\nmyString <- "new value"\nprint(myString)\n')),(0,r.kt)("h3",{id:"asynctasks"},"Async/Tasks"),(0,r.kt)("p",null,"For functions that perform IO, you'll need to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"uply")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"task"),'\n"computation expression". A "computation expression" is a special F# language\nfeature for writing abstractions with a nice syntax. The ',(0,r.kt)("inlineCode",{parentName:"p"},"uply")," CE allows using\na specialized asynchronous structure called Ply (which is extremely similar to a\n.Net Task) easily, and can best be illustrated with an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"  (function\n  | state, [ DObj value; DStr key; DDB dbname ] ->\n      uply {\n        let db = state.dbs.[dbname]\n        let! _id = UserDB.set state true db key value\n        return DObj value\n      }\n  | _ -> incorrectArgs ())\n")),(0,r.kt)("p",null,"Let's break this down line by line:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"uply {"),": this creates the CE, whose return value will be a ",(0,r.kt)("inlineCode",{parentName:"li"},"Ply<'any>"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let db = state.dbs.[dbname]")," - this is just regular F# code"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let! _id = UserDB.set state true db key value")," - the special thing here is\nthe ",(0,r.kt)("inlineCode",{parentName:"li"},"let!")," - this line calls ",(0,r.kt)("inlineCode",{parentName:"li"},"UserDB.set"),", a function which returns a ",(0,r.kt)("inlineCode",{parentName:"li"},"Ply"),",\nand unwraps the ",(0,r.kt)("inlineCode",{parentName:"li"},"Ply"),". This means that ",(0,r.kt)("inlineCode",{parentName:"li"},"_id")," can be treated as a normal value\nfor the rest of this ",(0,r.kt)("inlineCode",{parentName:"li"},"taskv"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"return DObj value")," - return takes an ordinary value and turns it into a\n",(0,r.kt)("inlineCode",{parentName:"li"},"Ply"),", in this case a ",(0,r.kt)("inlineCode",{parentName:"li"},"Ply<Dval>"),".")),(0,r.kt)("p",null,"Why do we go through all this trouble? Because this is an async runtime, and\n",(0,r.kt)("inlineCode",{parentName:"p"},"let!")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"return")," are the enablers of the asynchronicity. A ",(0,r.kt)("inlineCode",{parentName:"p"},"Ply")," is a\npromise, and ",(0,r.kt)("inlineCode",{parentName:"p"},"let!")," waits for the promise and then continues (running other code\nwhile the IO is still pending). This is the exact same as the ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," keyword in\nJS, Rust, C# or Python."),(0,r.kt)("p",null,"Note that while we primarily use ",(0,r.kt)("inlineCode",{parentName:"p"},"Ply")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"uply")," inside the Interpreter, most\nof our other async code use ",(0,r.kt)("inlineCode",{parentName:"p"},"Task")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"task"),". These are interchangeable except\nthat Tasks are a little slower."),(0,r.kt)("h3",{id:"advanced-functions"},"Advanced functions"),(0,r.kt)("h4",{id:"partial-application--currying"},"Partial application / currying"),(0,r.kt)("p",null,"Occasionally you'll see a function called with fewer arguments than it has\nparameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let myFunction (param1: int) (param2 : string) =\n  ...body...\n\nlet myOtherFunction = myFunction 6\n")),(0,r.kt)("p",null,'This is called "partial application", in that the function is only partially\ncalled (this is often called ',(0,r.kt)("em",{parentName:"p"},"Currying")," in the functional language community).\nThis just means that some parameters are filled in, and you now have a function\nwhich can be called with the remaining parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},'let () =\n  myOtherfunction "final argument"\n')),(0,r.kt)("p",null,"This is the same as if it were defined as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-fsharp"},"let myOtherFunction (param : string) =\n  myFunction 6 param\n")),(0,r.kt)("h2",{id:"darklangs-codebase-history"},"Darklang's codebase history"),(0,r.kt)("p",null,"Darklang's backend was originally written in OCaml, and then ported to F# in\n2021/2022. A lot of code is written the way it is because that made sense in\nOCaml, especially code with the comment ",(0,r.kt)("inlineCode",{parentName:"p"},"// CLEANUP")," in it."),(0,r.kt)("p",null,"Darklang's frontend was originally written in Elm, before being ported to\nReScript. It was removed in 2023."))}c.isMDXComponent=!0}}]);